Пример использования [библиотеки](FlowKitSampleApp/Sources/FlowKit) для координации флоу.

## Цель

Не отходя от концепции координаторов флоу, библиотека пытается решить несколько связанных с ними проблем:

- Протекание логики в координатор, что приводит к распуханию и появлению лишних ответственностей
- Протекание сущностей в координатор, что приводит к появлению шареного стейта и связанных с ним сайд-эффектов
- Отсутствие стандартного способа переиспользовать флоу как часть другого флоу

Все эти проблемы решаются и без дополнительных библиотек, если флоу готовить правильно. Цель данной библиотеки – не давать готовить неправильно, полноценно выполняя задачу координации.

## Термины

- Шаги, ноды – составные элементы флоу, содержащию логику каких-либо действий, совершаемых при прохождении данного флоу

## Детали реализации

Основными «строительными блоками» флоу являются типы `FlowAction` и `FlowNode`:

- `FlowAction` – обычные [промисы](https://en.wikipedia.org/wiki/Futures_and_promises), принимающие `FlowNode` в качестве шагов, и не предоставляющие прямой доступ к своему *значению*.

- `FlowNode` – абстракция, подобная `(Input) -> FlowAction<Output>`, но заставляющая выносить свою логику в отдельные сущности, и дающая возможность строить цепочки, где `Input` предыдущего шага связан с `Output`-ом следующего.

    ```swift
    protocol FlowNode {
        associatedtype Input
        associatedtype Output

        func makeAction(with: Input) -> FlowAction<Output>
    }
    ```

### Примеры

- [Пример флоу](FlowKitSampleApp/Sources/TransferFlowFeature/Public/TransferFlow.swift)
- [Примеры реализации шагов](FlowKitSampleApp/Sources/TransferFlowFeature/Internal/Nodes)

## Итог

Проблема протекающей логики решается `FlowNode`-ами, которые инкапсулируют логику шагов.

Проблема протекающих сущностей решается тем, что результат работы нод не возвращается во флоу ни в каком виде.

Задача переиспользования флоу решается тем, что само флоу является реализацией `FlowNode`, и поэтому может являться шагом в других флоу.
